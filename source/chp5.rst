.. _chp5index:

================
pandas入门
================

在本书的剩下部分，pandas将是我们最敢兴趣的主要库。它包含高级的数据结构和精巧的工具，使得在Python中处理数据非常快速和简单。pandas建造在NumPy之上，它使得以NumPy为中心的应用很容易使用。

作为一点儿背景，早在2008年，我任职于AQR（一个量化投资管理公司）开始构建pandas。当时，我有一组不同的需求，但对于我不能有一个单一的工具来很好的解决： ::

 * 支持自动或明确的数据对齐的带有标签轴的数据结构。这可以防止由数据不对齐引起的常见错误，并可以处理不同来源的不同索引数据。
 * 整合的时间序列功能。
 * 以相同的数据结构来处理时间序列和非时间序列。
 * 支持传递元数据（坐标轴标签）的算数运算和缩减。
 * 灵活处理丢失数据。
 * 在常用的基于数据的数据库（例如基于SQL）中的合并和其它关系操作。

我想要在一个地方能够做上面的所有的事情，最好是在一个非常适合于通用软件开发的语言中。Python是一个很好的候选，但是在那个时候没有一个完整的数据结构和工具的集合来提供这些功能。

在过去的四年里，pandas出乎我的意料，已经成熟到一个非常大的库，可以解决非常广泛的数据处理问题。虽然它的使用范围扩大了，但并没有抛弃我最初所渴望的简单和易使用性。我希望，通过阅读本书后，你会想我一样的发现它是一个必不可少的工具。

在本书的剩余部分，我对pandas使用下面的导入惯例： ::

  In [1]: from pandas import Series, DataFrame
  In [2]: import pandas as pd

pandas数据结构入门
=========================

为了开始使用pandas，你需要熟悉它的两个重要的数据结构： *Series* 和 *DataFrame* 。虽然它们不是没一个问题的通用解决方案，但提供了一个坚实的，易于使用的大多数应用程序的基础。

Series
-----------

Series是一个一维的类似的数组对象，包含一个数组的数据（任何NumPy的数据类型）和一个与数组关联的数据标签，被叫做 *索引* 。最简单的Series是由一个数组的数据构成： ::

  P112

Seriers的交互式显示的字符窜表示形式是索引在左边，值在右边。因为我们没有给数据指定索引，一个包含整数0到 `N-1` （这里N是数据的长度）的默认索引被创建。 你可以分别的通过它的 `values` 和 `index` 属性来获取Series的数组表示和索引对象： ::

  P112

通常，需要创建一个带有索引来确定没一个数据点的Series： ::

  p112

与正规的NumPy数组相比，你可以使用索引里的值来选择一个单一值或一个值集： ::

  P113

NumPy数组操作，例如通过一个布尔数组过滤，纯量乘法，或使用数学函数，将会保持索引和值间的关联： ::

  P113


另一种思考的方式是，Series是一个定长的，有序的字典，因为它把索引和值映射起来了。它可以适用于许多期望一个字典的函数： ::

  P113

如果你有一些数据在一个Python字典中，你可以通过传递字典来从这些数据创建一个Series： ::

   P113

只传递一个字典的时候，结果Series中的索引将是排序后的字典的建。

  P114

在这种情况下， **sdata** 中的3个值被放在了合适的位置，但因为没有发现对应于 **'California'** 的值，就出现了 **NaN** （不是一个数），这在pandas中被用来标记数据缺失或 *NA* 值。我使用“missing”或“NA”来表示数度丢失。在pandas中用函数 **isnull** 和 **notnull** 来检测数据丢失： ::

  P114

Series也提供了这些函数的实例方法： ::

  P114

有关数据丢失的更详细的讨论将在本章的后面进行。

在许多应用中Series的一个重要功能是在算数用算中它会自动对齐不同索引的数据： ::

  P114

数据对齐被安排为一个独立的话题。

Series对象本身和它的索引都有一个 **name** 属性，它和pandas的其它一些关键功能整合在一起： ::

  P115

Series的索引可以通过赋值就地更改： ::

  P115

DataFrame
-----------------



给一个不存在的列赋值，将会创建一个新的列。 像字典一样 **del** 关键字将会删除列： ::

  P118

.. twarning::
    
     索引DataFrame时返回的列是底层数据的一个视窗，而不是一个拷贝。因此，任何在Series上的就地修改都会影响DataFrame。列可以使用Series的 **copy** 函数来显式的拷贝。

另一种通用的数据形式是一个嵌套的字典的字典格式： ::

  P118

如果被传递到DataFrame，它的外部键会被解释为列索引，内部键会被解释为行索引： ::

  P118

当然，你总是可以对结果转置： ::

  P118

内部字典的键被结合并排序来形成结果的索引。如果指定了一个特定的索引，就不是这样的了： ::

  P119

Series的字典也以相同的方式来处理： ::

  P119

你可以传递到DataFrame构造器的东西的完整清单，见\ `表格5-1`_\ 。

如果一个DataFrame的 **index** 和 **columns** 有它们的 **name** ，也会被显示出来： ::

  p119

像Series一样， **values** 属性返回一个包含在DataFrame中的数据的二维ndarray： ::
  
  P119

如果DataFrame的列有不同的dtypes，返回值数组将会给所有的列选择一个合适的dtyps： ::

  P119

.. _`表格5-1`:

.. list-table:: 可能的传递到DataFrame的构造器
   :widths: 20, 40
   :header-rows: 1

   * - 二维ndarray
     - 一个数据矩阵，有可选的行标和列标
   * - 数组，列表或元组的字典
     - 每一个序列成为DataFrame中的一列。所有的序列必须有相同的长度。
   * - NumPy的结构/记录数组
     - 和“数组字典”一样处理
   * - Series的字典
     - 每一个值成为一列。如果没有明显的传递索引，将结合每一个Series的索引来形成结果的行索引。
   * - 字典的字典
     - 每一个内部的字典成为一列。和“Series的字典”一样，结合键值来形成行索引。
   * - 字典或Series的列表
     - 每一项成为DataFrame中的一列。结合字典键或Series索引形成DataFrame的列标。
   * - 列表或元组的列表
     - 和“二维ndarray”一样处理
   * - 另一个DataFrame
     - DataFrame的索引将被使用，除非传递另外一个
   * - NumPy伪装数组（MaskedArray）
     - 除了蒙蔽值在DataFrame中成为NA/丢失数据之外，其它的和“二维ndarray”一样


索引对象
-----------

pandas的索引对象用来保存坐标轴标签和其它元数据（如坐标轴名或名称）。构建一个Series或DataFrame时任何数组或其它序列标签在内部转化为索引： ::

  P120

索引对象是不可变的，因此不能由用户改变： ::

  P120

索引对象的不可变性非常重要，这样它可以在数据结构中结构中安全的共享： ::

  P121

`表格5-2`_ 是库中内建的索引类清单。通过一些开发努力，索引可以被子类化，来实现特定坐标轴索引功能。

.. ttip::

     多数用户不必要知道许多索引对象的知识，但是它们仍然是pandas数据模型的重要部分。

.. _`表格5-2`:

.. list-table:: pandas中的主要索引对象
   :widths: 10, 20
   :header-rows: 1

   * - Index
     - 最通用的索引对象，使用Python对象的NumPy数组来表示坐标轴标签。
   * - Int64Index
     - 对整形值的特化索引。
   * - MultiIndex
     - “分层”索引对象，表示单个轴的多层次的索引。可以被认为是类似的元组的数组。
   * - DatetimeIndex
     - 存储纳秒时间戳（使用NumPy的datetime64 dtyppe来表示）。
   * - PeriodIndex
     - 对周期数据（时间间隔的）的特化索引。

除了类似于阵列，索引也有类似固定大小集合一样的功能： ::

  P121

每个索引都有许多关于集合逻辑的方法和属性，且能够解决它所包含的数据的常见问题。这些都总结在\ `表格5-3`_ 中。

.. _`表格5-3`:

.. list-table:: 索引方法和属性
   :widths: 10, 20
   :header-rows: 1

   * - append
     - 链接额外的索引对象，产生一个新的索引
   * - diff
     - 计算索引的差集
   * - intersection
     - 计算交集
   * - union
     - 计算并集
   * - isin
     - 计算出一个布尔数组表示每一个值是否包含在所传递的集合里
   * - delete
     - 计算删除位置i的元素的索引
   * - drop
     - 计算删除所传递的值后的索引
   * - insert
     - 计算在位置i插入元素后的索引
   * - is_monotonic
     - 返回True，如果每一个元素都比它前面的元素大或相等
   * - is_unique
     - 返回True，如果索引没有重复的值
   * - unique
     - 计算索引的唯一值数组

重要的功能
=============

在本节中，我将带你穿过Series或DataFrame所包含的数据的基础结构的相互关系。在接下来的章节中，将要更深入的探究使用pandas进行数据分析和处理的主题。本书并不想要作为一个关于pandas库的详尽的文档；反而我将注意力集中在最重要的特性上，让不常见（也就是，比较深奥）的东西，你去自己探索。

重新索引
-----------

pandas对象的一个关键的方法是 **reindex** ，意味着使数据符合一个新的索引来构造一个新的对象。来看一下下面一个简单的例子： ::

  P122

在Series上调用 **reindex** 重排数据，使得它符合新的索引，如果那个索引的值不存在就引入缺失数据值： ：：

  P122

为了对时间序列这样的数据排序，当重建索引的时候可能想要对值进行内插或填充。 **method** 选项可以是你做到这一点，使用一个如 **ffill** 的方法来向前填充值： ::

  P123

`表格5-4`_ 是可用的 **method** 选项的清单。在此，内差比正向和反向填充更复杂。

.. _`表格5-4`:

.. list-table:: reindex 的 method（内插）选项
   :widths: 10, 15
   :header-rows: 1

   * - 参数
     - 描述

   * - ffill或pad
     - 前向（或进位）填充
   * - bfill或backfill
     - 后向（或进位）填充

对于DataFrame， **reindex** 可以改变（行）索引，列或两者。当只传入一个序列时，结果中的行被重新索引了： ::

  P123

使用 **columns** 关键字可以是列重新索引： ::

  P124

一次可以对两个重新索引，可是插值只在行侧（0坐标轴）进行： ::

  P124

正如你将看到的，使用带标签索引的 **ix** 可以把重新索引做的更简单： ::

  P124

.. list-table:: reindex 函数的参数
   :widths: 10, 20
   :header-rows: 1

   * - index
     - 作为索引的新序列。可以是索引实例或任何类似序列的Python数据结构。一个索引被完全使用，没有任何拷贝。
   * - method
     - 插值（填充）方法，见\ `表格5-4`_\ 的选项
   * - fill_value
     - 代替重新索引时引入的缺失数据值
   * - limit
     - 当前向或后向填充时，最大的填充间隙
   * - level
     - 在多层索引上匹配简单索引，否则选择一个子集
   * - copy
     - 如果新索引与就的相等则底层数据不会拷贝。默认为True(即始终拷贝）

next
==========

